<!DOCTYPE html>
<html lang="ja">
<!--
    Copyright (c) 2014 Kei Misawa

    This software is released under the MIT License.

    http://opensource.org/licenses/mit-license.php
-->
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Create GPX Route with Google Maps API v3</title>
<meta name="keywords" content="Google,Maps,GPX,Route,Create,マップ,作成">
<meta name="description" content="Create GPX file of routes with Google Maps API v3">
<meta name="author" content="330k">
<meta name="application-name" content="GMaps2GPX">
<!-- WebApp -->
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">

<link rel="stylesheet" href="http://code.jquery.com/mobile/1.4.2/jquery.mobile-1.4.2.min.css" />
<link rel="apple-touch-icon" sizes="57x57" href="apple-touch-icon-57x57.png" />
<link rel="apple-touch-icon" sizes="60x60" href="apple-touch-icon-60x60.png" />
<link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png" />
<link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16" />
<link rel="manifest" href="manifest.json" />

<meta name="msapplication-TileColor" content="#da532c" />
<meta name="theme-color" content="#ffffff" />
<style type="text/css">
html	{ height: 100%; }
body	{ height: 100%; margin: 0; padding: 0; user-select: none;}

#page_map	{ overflow: hidden; }
#map_canvas	{ position: absolute; left: 0px; top: 0px; width: 100%; height: 80%; }
#graph_canvas	{ position: absolute; left: 0px; top: 80%; width: 100%; height: 20%; overflow: hidden; padding: 1px; }

#gpx_text	{ display: none; }
</style>
</head>
<body>

<div data-role="header" data-position="fixed" data-theme="b" class="ui-state-persist" id="header">
	<div data-role="navbar">
		<ul>
			<li><a href="#page_search" data-transition="none" class="ui-btn-active">Search</a></li>
			<li><a href="#page_map" data-transition="none">Map</a></li>
			<li><a href="#page_gpx" data-transition="none">GPX</a></li>
			<li><a href="#page_directions" data-transition="none">Directions</a></li>
		</ul>
	</div>
</div>

<div id="page_search" data-role="page" data-pagename="Search">
 <div role="main" class="ui-content">
 <form>
 Origin:
 <div><input id="input_origin" type="text" value="東京駅" /></div>
 <div id="waypoints" data-role="collapsible">
 <h3>Via:</h3>
  <input id="input_waypoint_01" type="text" value="" />
  <input id="input_waypoint_02" type="text" value="" />
  <input id="input_waypoint_03" type="text" value="" />
  <input id="input_waypoint_04" type="text" value="" />
  <input id="input_waypoint_05" type="text" value="" />
  <input id="input_waypoint_06" type="text" value="" />
  <input id="input_waypoint_07" type="text" value="" />
  <input id="input_waypoint_08" type="text" value="" />
 </div>
 Destination:
 <div><input id="input_destination" type="text" value="横浜駅" /></div>
 <div><label><input id="input_avoid_highways" type="checkbox" checked="checked" value=""/>Avoid Highways</label></div>
 <div><label><input id="input_avoid_tolls" type="checkbox" checked="checked" value=""/>Avoid Tolls</label></div>
 <div><label><input id="input_optimize_waypoints" type="checkbox" value=""/>Optimize waypoints</label></div>
 <select id="select_travel_mode">
  <option value="DRIVING" selected="selected">Driving</option>
  <option value="WALKING">Walking</option>
 </select>
 <input type="submit" id="button_calc_route" value="Calculate Route" />
 </form>
 </div>
</div>

<div id="page_map" data-role="page" data-pagename="Map">
 <div role="main" class="ui-content">
 <div id="map_canvas"></div>
 <div id="graph_canvas"></div>
 </div>
</div>

<div id="page_gpx" data-role="page" data-pagename="GPX">
 <div role="main" class="ui-content">
 <div id="page_gpx_001">
  Download File Name:
  <input id="input_download_filename" type="text" value="download.gpx" />
  <a id="gpx_download_link">Download</a>
  <select id="select_reduce_points">
   <option value="100">Reduce into 100 points</option>
   <option value="200">Reduce into 200 points</option>
   <option value="400">Reduce into 400 points</option>
   <option value="800" selected="selected">Reduce into 800 points</option>
   <option value="2000">Reduce into 2000 points</option>
   <option value="4000">Reduce into 4000 points</option>
   <option value="8000">Reduce into 8000 points</option>
   <option value="0">No reduction</option>
  </select>
  <div id="gpx_info"></div>
 </div>
 <textarea id="gpx_text" readonly="readonly" wrap="soft"></textarea>
 </div>
</div>

<div id="page_directions" data-role="page" data-pagename="Directions">
 <div role="main" class="ui-content">
 <div id="directions_panel"></div>
 </div>
</div>

<!--<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.2/jquery.mobile.min.js"></script>
<script type="text/javascript" src="http://code.highcharts.com/highcharts.js"></script>-->
<script type="text/javascript" defer="defer">
/* global google, BlobBuilder */
var map;
var gpxdata = {
	name: '',
	bounds: {
		minlat: 0, minlon: 0, maxlat: 0, maxlon: 0
	},
	desc: '',
	trksegs: [[]]
};
var directionsDisplay = null;
var directionsService = null;
var elevationService = null;

navigator.standalone = navigator.standalone || (screen.height-document.documentElement.clientHeight<40);

function loadScript(url){
	'use strict';
	var script = document.createElement("script");
	script.type = "text/javascript";
	script.src = url[0];
	if(url.length > 1){
		script.onload = function(){
			loadScript(url.slice(1));
		};
	}
	document.body.appendChild(script);
}
loadScript([
	'http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js',
	'http://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.2/jquery.mobile.min.js',
	'http://code.highcharts.com/highcharts.js',
	'http://maps.google.com/maps/api/js?sensor=true&callback=initialize'
]);

function initialize(){
	'use strict';
	// jQuery Mobile Initialize
	$( "[data-role='header'], [data-role='footer']" ).toolbar();
	
	$(document).on('pageshow', '[data-role="page"]', function() {
		var current = $(this).jqmData('pagename');
		$('[data-role="navbar"] a.ui-btn-active').removeClass('ui-btn-active');
		$('[data-role="navbar"] a').each(function() {
			var $this = $(this);
			if($this.text() === current){
				//with({$this: $this}){
				(function($this){
					setTimeout(function(){
						$this.addClass('ui-btn-active');
					}, 0);
				})($this);
			}
		});
	});
	$('#page_map').on('pageshow', function(){
		$('#page_map').css('margin-top', $('#header').height());
		$('#page_map').height($(window).innerHeight() - $('#header').height() * 2 - 2);
		if($('#graph_canvas').highcharts()){
			$('#graph_canvas').highcharts().setSize($('#graph_canvas').innerWidth(), $('#graph_canvas').innerHeight());
		}
		
		if(typeof map === 'undefined'){
			// Google Maps Initialize
			$.mobile.loading('show', {
				text: 'initializing google maps...',
				textVisible: true
			});
			map = new google.maps.Map(document.getElementById('map_canvas'), {
				zoom: 6,
				mapTypeId: google.maps.MapTypeId.ROADMAP,
				center: new google.maps.LatLng(35.681382, 139.766084)
			});
			directionsDisplay.setMap(map);
			google.maps.event.addListener(map, 'tilesloaded', function(){
				$.mobile.loading('hide');
			});
		}
		google.maps.event.trigger(map, 'resize');
		map.setZoom(map.getZoom());
	});
	
	$('body > div[id!="page_map"], #graph_canvas').on('swipeleft', function(){
		var next = $(document.body).pagecontainer('getActivePage')[0].nextElementSibling;
		if(next && next.getAttribute('data-role') === 'page'){
			$(document.body).pagecontainer('change', '#' + next.id);
		}
	}).on('swiperight', function(){
		var prev = $(document.body).pagecontainer('getActivePage')[0].previousElementSibling;
		if(prev && prev.getAttribute('data-role') === 'page'){
			$(document.body).pagecontainer('change', '#' + prev.id);
		}
	});
	$.mobile.defaultPageTransition = 'none';
	
	directionsDisplay = new google.maps.DirectionsRenderer({
		draggable: true
	});
	directionsDisplay.setPanel(document.getElementById('directions_panel'));
	directionsService = new google.maps.DirectionsService();
	elevationService = new google.maps.ElevationService();

	// Route Drag on Map
	google.maps.event.addListener(directionsDisplay, 'directions_changed', function() {
		createGPXFromDirections(directionsDisplay.directions);
		updateSearchConditions(directionsDisplay.directions);
		$('#gpx_download_link').button('enable');
		//$('#button_add_elevation').button('enable');
		$('#select_reduce_points').selectmenu('enable');
	});
	
	// Input Check
	var geocodingService = new google.maps.Geocoder();
	$('#page_search input[type="text"]').blur(function(){
		var $input = $(this);
		if($input.val() !== ''){
			geocodingService.geocode({'address': $input.val()}, function(results, status) {
				if(status === google.maps.GeocoderStatus.OK){
					$input.removeClass('ui-state-error');
				}else{
					$input.addClass('ui-state-error');
				}
			});
		}else{
			$input.removeClass('ui-state-error');
		}
	});
	
	// Button Events
	$('#button_calc_route').attr('title', 'calculate route').click(function(event){
		calcRoute();
		event.preventDefault();
	});
	
	$('#gpx_download_link').button({disabled: true}).attr('title', 'download gpx file to your PC');
	$('#select_reduce_points').selectmenu({disabled: true}).change(function(){
		simplifyGPX($('#select_reduce_points').val());
		createGPXDownloadLink();
	});
	
	$('#graph_canvas').click(function(){
		$.mobile.loading('show', {
			text: 'adding elevation...',
			textVisible: true
		});
		addElevationToGPX(function(mes){
			if(mes.state === 'finished'){
				createGPXDownloadLink();
				$.mobile.loading('hide');
			}else{
				$.mobile.loading('show', {
					text: 'adding elevation... ' + mes.value + '/' + mes.max,
					textVisible: true
				});
			}
		});
	});
	
	$('#input_download_filename').change(function(){
		$('#gpx_download_link').attr('download', $(this).val());
	});
	
	createGPXDownloadLink();
}

function calcRoute() {
	'use strict';
	var waypoints = [];
	for(var i = 1; i <= 8; i++){
		if(document.getElementById('input_waypoint_' + ('0' + i).slice(-2)).value){
			waypoints.push({
				location: document.getElementById('input_waypoint_' + ('0' + i).slice(-2)).value,
				stopover: document.getElementById('input_optimize_waypoints').checked
			});
		}
	}
	var request = {
		origin: document.getElementById('input_origin').value,
		destination: document.getElementById('input_destination').value,
		travelMode: google.maps.TravelMode[document.getElementById('select_travel_mode').value],
		avoidHighways: document.getElementById('input_avoid_highways').checked,
		avoidTolls: document.getElementById('input_avoid_tolls').checked,
		waypoints: waypoints,
		optimizeWaypoints: document.getElementById('input_optimize_waypoints').checked
	};
	$.mobile.loading('show', {
		text: 'calculating route...',
		textVisible: true
	});
	
	directionsService.route(request, function(response, status) {
		if (status === google.maps.DirectionsStatus.OK) {
			$('#page_map').one('pageshow', function(){
				directionsDisplay.setDirections(response);
			});
			$.mobile.loading('hide');
			$(document.body).pagecontainer('change', '#page_map');
		} else {
			$.mobile.loading('hide');
			$('<div style="padding: 10px;">ルートが見つかりませんでした<\/div>').popup({
				history: false,
				themte: 'a',
				overlayTheme: 'a',
				positionTo: 'window',
				afterclose: function(){
					$(this).popup('destroy');
				}
			}).popup('open');
		}
	});
}

function createGPXFromDirections(response){
	'use strict';
	var route = response.routes[0];
	var bounds = route.bounds.toUrlValue().split(',');
	
	gpxdata.bounds.minlat = bounds[0];
	gpxdata.bounds.minlon = bounds[1];
	gpxdata.bounds.maxlat = bounds[2];
	gpxdata.bounds.maxlon = bounds[3];
	gpxdata.desc = route.copyrights;
	gpxdata.name = route.legs[0].start_address + ' to ' + route.legs[route.legs.length - 1].end_address;
	gpxdata.trksegs = [[]];
	
	var oldlat = 540;
	var oldlng = 540;
	var trkseg = gpxdata.trksegs[0];
	for(var i = 0; i < route.legs.length; i++){
		for(var j = 0; j < route.legs[i].steps.length; j++){
			for(var k = 0; k < route.legs[i].steps[j].path.length; k++){
				var lat = route.legs[i].steps[j].path[k].lat();
				var lng = route.legs[i].steps[j].path[k].lng();
				
				if((lat !== oldlat) || (lng !== oldlng)){
					trkseg.push({
						lat: lat,
						lon: lng,
						enabled: true,
						ele: null,
						priority: null
					});
					oldlat = lat;
					oldlng = lng;
				}
			}
		}
	}
	
	simplifyGPX($('#select_reduce_points').val());
	createGPXDownloadLink();
}

function updateSearchConditions(response){
	'use strict';
	var route = response.routes[0];
	
	$('#input_origin').val(route.legs[0].start_address);
	$('#input_destination').val(route.legs[route.legs.length - 1].end_address);
	/*for(var i = 1; i < route.legs.length; i++){
		$('#input_waypoint_' + ('0' + i).slice(-2)).val(
			route.legs[i].start_address
		);
	}*/
}

function createGPXDownloadLink(){
	'use strict';
	try{
		var buf = [];
		
		buf.push('<?xml version="1.0" encoding="UTF-8"?>');
		buf.push('<gpx' +
			' version="1.0"' +
			' creator="Create GPX Route with Google Maps API v3"' +
			' xmlns="http://www.topografix.com/GPX/1/0"' +
			' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"' +
			' xsi:schemaLocation="http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd"' +
			'>');
		buf.push('<desc>' + escapeXMLString(gpxdata.desc) + '<\/desc>');
		buf.push('<url>http://www.330k.info/<\/url>');
		buf.push('<bounds' +
			' minlat="' + gpxdata.bounds.minlat + '"' +
			' minlon="' + gpxdata.bounds.minlon + '"' +
			' maxlat="' + gpxdata.bounds.maxlat + '"' +
			' maxlon="' + gpxdata.bounds.maxlon + '"' +
			' /\>');
		buf.push('<trk>');
		buf.push('<name>' + escapeXMLString(gpxdata.name) + '<\/name>');
		buf.push('<trkseg>');
		var trkseg = gpxdata.trksegs[0];
		for(var i = 0; i < trkseg.length; i++){
			if(trkseg[i].enabled){
				buf.push('<trkpt lat="' + trkseg[i].lat.toFixed(5) +
					'" lon="' + trkseg[i].lon.toFixed(5) + '">' +
					((trkseg[i].ele !== null) ? '<ele>' + trkseg[i].ele.toFixed(2) + '<\/ele>': '') +
					'<\/trkpt>');
			}
		}
		buf.push('<\/trkseg>');
		buf.push('<\/trk>');
		buf.push('<\/gpx>');
		
		var gpx = buf.join('\n');
		document.getElementById('gpx_text').value = gpx;
		var e = document.getElementById('gpx_download_link');
		
		window.URL = window.URL || window.webkitURL;
		window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
		if(window.URL && window.URL.createObjectURL){
			var blob = null;
			try{
				blob = new Blob([gpx], {type:'application/xml'});
			}catch(err){
				var bb = new BlobBuilder();
				bb.append(gpx);
				blob = bb.getBlob('application/xml');
			}
			
			e.href = window.URL.createObjectURL(blob);
		}else{
			e.href = 'data:application/octet-stream,' + encodeURIComponent(gpx);
			e.setAttribute('target', '_blank');
		}
		e.setAttribute('download', document.getElementById('input_download_filename').value);
		
		setTimeout(function(){
			var info = calcDistance();
			$('#gpx_info').html(
				'<div>' + trkseg.length + ' points to ' + info.points + ' points<\/div>' +
				'<div>Total Distance: ' + (info.total_distance * 0.001).toFixed(3) + ' km<\/div>' +
				'<div>Total Elevation: ' + info.total_elevation.toFixed(2) + ' m<\/div>'
			);
			$('#graph_canvas').highcharts(createGraphData());
		}, 0);
		
	}catch(err){
		//alert('ブラウザが対応していません');
		alert(err);
	}
}

function escapeXMLString(str){
	'use strict';
	var result = str;
	
	if(typeof result === 'string'){
		result = result.replace('&', '&amp;');
		result = result.replace('>', '&gt;');
		result = result.replace('<', '&lt;');
		result = result.replace('"', '&quot;');
		result = result.replace('\'', '&apos;');
	}else{
		result = '';
	}
	
	return result;
}

var calcDistance = (function(){
	'use strict';
	
	var hubeny = (function(){
		var a = 6378137.0;
		var b = 6356752.314245;
		var f2 = b * b / (a * a);
		var e2 = 1.0 - f2;
		var degree = Math.PI / 180.0;
		var sin = Math.sin;
		var cos = Math.cos;
		var sqrt = Math.sqrt;
		return function (lat1, lon1, lat2, lon2){
			var latdiff = (lat1 - lat2) * degree;
			var londiff = (lon1 - lon2) * degree;
			var latave = 0.5 * (lat1 + lat2) * degree;
			var sinlatave = sin(latave);
			var coslatave = cos(latave);
			var w2 = 1.0 - sinlatave * sinlatave * e2;
			var w = sqrt(w2);
			var meridian = a * f2 / (w2 * w);
			var n = a / w;
	
			return sqrt(
				latdiff * latdiff * meridian * meridian +
				londiff * londiff * n * n * coslatave * coslatave
			);
		}
	})();
	
	return function(){
		var total_dist = 0.0;
		var total_ele = 0.0;
		var oldele = null;
		
		if(typeof gpxdata.trksegs[0][0] === 'undefined'){
			return {
				points: 0,
				total_distance: 0.0,
				total_elevation: 0.0
			};
		}
		
		var enabledtrkpts = [];
		var trkseg = gpxdata.trksegs[0];
		var i = 0;
		for(i = 0; i < trkseg.length; i++){
			if(trkseg[i].enabled){
				enabledtrkpts.push(trkseg[i]);
			}
		}
		
		trkseg[0].total_distance = 0.0;
		for(i = 1; i < enabledtrkpts.length; i++){
			total_dist += hubeny(
				enabledtrkpts[i - 1].lat,
				enabledtrkpts[i - 1].lon,
				enabledtrkpts[i].lat,
				enabledtrkpts[i].lon
			);
			
			if(enabledtrkpts[i].ele !== null){
				if((oldele !== null) && (enabledtrkpts[i].ele > oldele)){
					total_ele += enabledtrkpts[i].ele - oldele;
				}
				oldele = enabledtrkpts[i].ele;
			}
			enabledtrkpts[i].total_distance = total_dist;
			enabledtrkpts[i].total_elevation = total_ele;
		}
		
		return {
			points: enabledtrkpts.length,
			total_distance: total_dist,
			total_elevation: total_ele
		};
	};
})();

var addElevationToGPX = (function(){
	'use strict';
	var UNIT = 100;
	var WAIT = 1000;
	
	var elecache = {};
	
	if(typeof localStorage !== 'undefined'){
		try{
			elecache = JSON.parse(localStorage.getItem('elecache'));
			if(elecache === null){
				elecache = {};
			}
		}catch(err){
		}
	}
	
	function getElevation(locations, callback) {
		elevationService.getElevationForLocations({
			locations: locations
		}, function(results, status) {
			if (status === google.maps.ElevationStatus.OK) {
				callback(results);
			} else if (status === google.maps.ElevationStatus.INVALID_REQUEST) {
				console.log('リクエストに問題アリ！requestで渡している内容を確認せよ！！');
			} else if (status === google.maps.ElevationStatus.OVER_QUERY_LIMIT) {
				console.log('短時間にクエリを送りすぎ！落ち着いて！！');
			} else if (status === google.maps.ElevationStatus.REQUEST_DENIED) {
				console.log('このページでは ElevationResult の利用が許可されていない！・・・なぜ！？');
			} else if (status === google.maps.ElevationStatus.UNKNOWN_ERROR) {
				console.log('原因不明のなんらかのトラブルが発生した模様。');
			} else {
				console.log('えぇ～っと・・、バージョンアップ？');
			}
		});
	}
	
	return function(callback){
		var locations = [];
		var count = 0;
	
		var enabledtrkpts = [];
		var trkseg = gpxdata.trksegs[0];
		var i = 0;
		var j = 0;
		
		for(i = 0; i < trkseg.length; i++){
			if((trkseg[i].enabled) && (trkseg[i].ele === null)){
				var cache = elecache[(new google.maps.LatLng(trkseg[i].lat, trkseg[i].lon)).toUrlValue()];
				if(cache){
					trkseg[i].ele = cache - 0;
				}else{
					enabledtrkpts.push(trkseg[i]);
				}
			}
		}
		var total = enabledtrkpts.length;
		
		if(total === 0){
			callback({
				state: 'finished',
				content: ''
			});
			return;
		}
		
		callback({
			state: 'processing',
			content: 'requesting... ',
			max: total,
			value: 0
		});
		// Google Elevations Service
		for(j = 0; j < total; j += UNIT){
			locations = [];
			for(i = j; (i < j + UNIT) && (i < total); i++){
				locations.push(new google.maps.LatLng(
					enabledtrkpts[i].lat,
					enabledtrkpts[i].lon
				));
			}
			(function(j, locations){
				setTimeout(function(){
					getElevation(locations, function(results){
						for(var i = 0; i < results.length; i++){
							enabledtrkpts[i + j].ele = results[i].elevation.toFixed(2) - 0;
							elecache[results[i].location.toUrlValue()] = results[i].elevation.toFixed(2);
						}
						count += locations.length;
			
						try{
							localStorage.setItem('elecache', JSON.stringify(elecache));
						}catch(err){
						}
						if(count >= total){
							callback({
								state: 'finished',
								content: ''
							});
						}else{
							callback({
								state: 'processing',
								content: 'processing... ' + count + '/' + total,
								max: total,
								value: count
							});
						}
					});
				}, j * WAIT / UNIT);
			})(j, locations);
		}
		callback({
			state: 'processing',
			content: 'processing... ' + 0 + '/' + total,
			max: total,
			value: 0
		});
	};
})();

var simplifyGPX = (function(){
	'use strict';

	var degree = Math.PI / 180.0;
	var quadpi = Math.PI / 4.0;
	function setPriorityToTrkpts(){
		if(typeof gpxdata.trksegs[0][0] === 'undefined'){
			return;
		}
		
		var pts = [];
		var trkseg = gpxdata.trksegs[0];
		
		// メルカトル図法で投影
		for(var i = 0; i < trkseg.length; i++){
			pts[i] = [
				trkseg[i].lon * degree,
				Math.log(Math.abs(Math.tan(quadpi + 0.5 * trkseg[i].lat * degree)))
			];
		}
	
		var queue = new PriorityQueue();
		var farthest = findFarthest(pts, 0, pts.length - 1);
		queue.enqueue(farthest.dist, farthest);
		trkseg[0].priority = 1;
		trkseg[pts.length - 1].priority = 2;
		var count = 2;
		
		while(queue.size()){
			var v = queue.dequeue();
			count++;
			if(v.pos >= 0){
				trkseg[v.pos].priority = count;
			}
		
			if(v.start + 2 <= v.pos){
				farthest = findFarthest(pts, v.start, v.pos);
				queue.enqueue(farthest.dist, farthest);
			}
			if(v.pos + 2 <= v.end){
				farthest = findFarthest(pts, v.pos, v.end);
				queue.enqueue(farthest.dist, farthest);
			}
		}

		return;
	}
	
	function findFarthest(pts, start, end){
		var ax = pts[start][0];
		var ay = pts[start][1];
		var bx = pts[end][0];
		var by = pts[end][1];
		var d = 0.0;
		var m = -Number.MAX_VALUE;
		var c = -1;
	
		for(var i = start + 1; i < end; i++){
			d = segmentPointDistance(ax, ay, bx, by, pts[i][0], pts[i][1]);
			if(m < d){
				m = d;
				c = i;
			}
		}
	
		return {start:start, end:end, pos:c, dist:m};
	}

	function segmentPointDistance(ax, ay, bx, by, px, py){
		var t = (ax * ax + ay * ay + bx * px - ax * (bx + px) + by * py - ay * (by + py))/(ax * ax + ay * ay - 2 * ax * bx + bx * bx - 2 * ay * by + by * by);
	
		if((0 <= t) && (t <= 1)){
			var x = ax - (ax - bx) * t;
			var y = ay - (ay - by) * t;
			
			return ((x - px) * (x - px) + (y - py) * (y - py));
		}else if(t > 1){
			return ((bx - px) * (bx - px) + (by - py) * (by - py));
		}else{
			// includes A === B
			return ((ax - px) * (ax - px) + (ay - py) * (ay - py));
		}
	}
	
	// Pairingヒープ
	function PriorityQueue(){
		this.name = 'Pairing Heap';
		this._size = 0;
		this._root = null;
	
		this._merge = function (i, j){
			if(i === null) return j;
			if(j === null) return i;
		
			if(i.p < j.p){
				var ret = i;
				i = j;
				j = ret;
			}
			j.next = i.head;
			i.head = j;
		
			return i;
		};
		this._mergeList = function (s){
			var n = null;
		
			while(s !== null){
				var a = s;
				var b = null;
				s = s.next;
				a.next = null;
				if(s !== null){
					b = s;
					s = s.next;
					b.next = null;
				}
				a = this._merge(a, b);
				a.next = n;
				n = a;
			}
			while(n !== null){
				var j = n;
				n = n.next;
				s = this._merge(j, s);
			}
			return s;
		};
	
		this.enqueue = function(priority, value){
			this._root = this._merge(this._root, {
				p: priority,
				v: value,
				next: null,
				head: null
			});
			this._size++;
		};
		this.dequeue = function(){
			var result = this._root.v;
			this._root = this._mergeList(this._root.head);
			this._size--;
		
			return result;
		};
		this.size = function(){
			return this._size;
		};
	
		return this;
	}
	
	return function(reduced_points){
		var reducedPoints = reduced_points || 400;
		var trkseg = gpxdata.trksegs[0];
		var i = 0;
		
		for(i = 0; i < trkseg.length; i++){
			if(trkseg[i].priority === null){
				setPriorityToTrkpts();
				break;
			}
		}
		
		if(reducedPoints <= 0){
			// make all points enabled
			for(i = 0; i < trkseg.length; i++){
				trkseg[i].enabled = true;
			}
		}else{
			for(i = 0; i < trkseg.length; i++){
				if(trkseg[i].priority <= reducedPoints){
					trkseg[i].enabled = true;
				}else{
					trkseg[i].enabled = false;			
				}
			}
		}
	};
})();

var createGraphData = (function(){
	'use strict';
	var marker = null;
	return function(){
		var trkseg = gpxdata.trksegs[0];
		var pointdata = {};
		var data = {
			chart: {
				type: 'area',
				animation: false,
				zoomType: 'none',
				events: {
					click: function(){
						$.mobile.loading('show', {
							text: 'adding elevation...',
							textVisible: true
						});
						addElevationToGPX(function(mes){
							if(mes.state === 'finished'){
								createGPXDownloadLink();
								$.mobile.loading('hide');
							}else{
								$.mobile.loading('show', {
									text: 'adding elevation... ' + mes.value + '/' + mes.max,
									textVisible: true
								});
							}
						});
					}
				}
			},
			legend: {
				enabled: false
			},
			title: null,
			xAxis: {
				title: {
					text: 'distance (km)'
				},
				gridLineWidth: 1,
				lineColor: '#000',
				tickColor: '#000',
				min: 0,
				max: trkseg[trkseg.length - 1].total_distance * 0.001
			},
			yAxis: {
				title: {
					text: 'evelation (m)'
				},
				gridLineWidth: 1,
				lineColor: '#000',
				tickColor: '#000'
			},
			plotLines: [{
				value: 0,
				width: 4,
				color: '#808080'
			}],
			plotOptions: {
				series: {
					animation: false,
					marker: {
						enabled: false
					},
					allowPointSelect: true,
					point: {
						events: {
							mouseOver: function(){
								map.setCenter(pointdata[this.x]);
								if(marker.getMap() === null){
									marker.setMap(map);
								}
								marker.setPosition(pointdata[this.x]);
							}
						}
					},
					events: {
						mouseOut: function(){
							marker.setMap(null);
						}
					}
				}
			},
			series: [{
				name: 'evelation',
				data: []
			}]
		};
		if(marker === null){
			marker = new google.maps.Marker({
				position: null,
				map: null
			});
		}
		
		for(var i = 0; i < trkseg.length; i++){
			if(trkseg[i].enabled && trkseg[i].total_distance && trkseg[i].ele){
				var dist = (trkseg[i].total_distance * 0.001).toFixed(3) - 0;
				data.series[0].data.push([
					dist,
					trkseg[i].ele.toFixed(2) - 0
				]);
				pointdata[dist] = new google.maps.LatLng(trkseg[i].lat, trkseg[i].lon);
			}
		}
		
		return data;
	};
})();

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-5655726-6', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>
